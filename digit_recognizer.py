# -*- coding: utf-8 -*-
"""
Created on Sat Feb 10 13:04:27 2018

@author     Valentin
@brief      Stuff to deal with digit recognition of a sudoku grid, from a pre-processed grid picture to a numpy array.

Sources:    https://stackoverflow.com/questions/9413216/simple-digit-recognition-ocr-in-opencv-python
            https://docs.opencv.org/trunk/d8/d4b/tutorial_py_knn_opencv.html
"""

import os

import numpy as np
import cv2
import time
from solving import chiffres_ligne, chiffres_colonne, chiffres_bloc
from alarm import alarm

def max_sous_contrainte(contours, height):
    """
    @param   contours   a list of contours generated by cv02.findContours
    @param   height     picture height (= picture weight)
    @return  cnt        a contour
    @brief   Permet de récupérer le plus grand contour d'une liste au sens de son aire.
    
    "Sous contrainte" : pour éviter de prendre en compte des contours non effacés ou autre arcefacts indésirables, des critères sur l'aire du contour ont été rajouté
    """
    cnt_max = []
    area_max=0
    for cnt in contours:
        [x,y,w,h] = cv2.boundingRect(cnt)
        
        #En général, les artefacts sont des bouts de ligne assez fins mais suffisamment longs pour avoir un contour d'aire supérieure à celle du digit en lui même. Ces critères permettent ainsi de supprimer ces imperfections. La deuxieme condition "or" permet la prise en compte de caractères fins (tel que le 1 sous certaines polices d'écriture), en jouant sur la position de ce dernier dans la case. 
        if (h > 0.1*height and w > 0.1*height and h < 0.9*height and w < 0.9*height) or (x > 0.4*height and y > 0.4*height and x < 0.6*height and y < 0.9*height):
            #On recherche dans ces conditions le contour ayant une aire la plus grande
            if cv2.contourArea(cnt)>area_max:
                area_max = cv2.contourArea(cnt)
                cnt_max = cnt
                
    return(cnt_max)


def Seg_case(img, i, j, ordre_sudoku) :
    """
    @param  img     a sudoku picture
    @param  i, j    indexes of a sudoku case
    @param  ordre_sodoku    the sudoku order (9 -> 9x9-sudoku)
    @return case    the (i,j)-case picture of the sudoku
    @brief  Permet d'isoler la case (ligne i, colonne j) du sudoku
    """

    dim = ordre_sudoku*100
    
    small = cv2.resize(img,(dim,dim))
    
    
    pas_x=dim//ordre_sudoku
    pas_y=dim//ordre_sudoku
    case=small[i*pas_x:(i+1)*pas_x , j*pas_y:(j+1)*pas_y]
    
    return case


def single_recognition(img, ordre_sudoku, angle):
    """
    @param  angle           orientation, en degré (0°, 90°, 180° ou 270°)
    @param  img             l'image à analyser
    @param  ordre_sudoku    ordre de la grille (ex : 9 pour un sudoku 9x9)
    
    Transforme une image "droite" (pouvant être orientée à 90°, 180° ou 270°)
    en un tableau numpy comportant les coefficients de la grille de sudoku
    """
     
    nb = 0
    nb_recognized_coef=0
    distance_totale=0
    iszero = False      #Permet de savoir si un zéro a été détecté dans la grille
    
    
    #Chargement de la base de donnée générée par l'apprentissage
    samples = np.loadtxt('digitsamples.data',np.float32)
    responses = np.loadtxt('digitresponses.data',np.float32)
    responses = responses.reshape((responses.size,1))
    
    #Création de la grille de sudoku
    #Une initialisation avec des coefficients n'appartenant pas à la grille est ici nécessaire pour permettre aux fonctions de vérification de conformité de la grille de fonctionner correctement.
    sudoku=10*np.ones((ordre_sudoku,ordre_sudoku))
    
    #Création et entraînement du modèle avec la base chargée
    model = cv2.ml.KNearest_create()
    model.train(samples,cv2.ml.ROW_SAMPLE,responses)
    
    height, width = img.shape

    
    #Rotation de l'image selon l'angle indiqué en paramètre
    M = cv2.getRotationMatrix2D((width/2,height/2),angle,1)
    im = cv2.warpAffine(img,M,(width,height))
        
    for i in range(ordre_sudoku):
        for j in range(ordre_sudoku):
            case = Seg_case(im, i, j, ordre_sudoku)
            case_copy = case
            
            height, weight = case.shape
            
            _, case = cv2.threshold(case,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)
            _, contours,hierarchy = cv2.findContours(np.copy(case), cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)
                                    
            if len(contours) != 0:
                
##                cv2.imshow('im', case_copy)
##                cv2.waitKey(0)
                
                cnt = max_sous_contrainte(contours, height)

                if len(cnt) != 0:
                    [x,y,w,h] = cv2.boundingRect(cnt)
                        
                    nb_recognized_coef +=1
                    
                    cv2.rectangle(case_copy,(x,y),(x+w,y+h),(50,100,150),1)
                    
                    roi = case[y:y+h,x:x+w]
                    roismall = cv2.resize(roi,(10,10))
##                    
##                    cv2.imshow('im', case_copy)
##                    cv2.waitKey(0)
                     
                    #"Redimensionnement" de l'image en un vecteur de 100 composantes
                    roismall = roismall.reshape((1,100))
                    roismall = np.float32(roismall)
                    
                    #Détection du digit via l'application de la méthode des k plus proches voisins
                    retval, results, neigh_resp, dists = model.findNearest(roismall, k = 10)
                    # print(neigh_resp)     #Affiche les k plus proches voisins
                    
                    resultat = int(results[0][0])
##                    print(resultat)       #Afficher le digit reconnnu
                    
                    #On vérifie qu'il ne s'agisse pas d'un zéro, et, le cas échéant, que la grille est bien valide avec l'ajout de ce nouveau digit.
                    if resultat == 0:
                        iszero = True
                    
                    if (resultat in chiffres_ligne(sudoku,i, False)) or (resultat in chiffres_colonne(sudoku,j,False)) or (resultat in chiffres_bloc(sudoku,i,j,False)):
                        return(sudoku,0,iszero)
                        
                        
                    distance_totale += dists[0][0]
                    sudoku[i][j]=resultat                 
                        
    proportion = distance_totale/nb_recognized_coef
    return(sudoku, proportion, iszero)



def recognition(im):
    """
    @param     im  the sudoku grid picture
    @return    grille   an array with the sudoku grid digits
    @brief     Fonction principale de la reconnaissance des chiffres

    Réalise une reconnaissance de la grille selon les 4 orientations possibles, puis détermine l'orientation donnant le meilleur résultat (en se basant sur la distance moyenne entre plus proche voisins). La grille correspondant à cette orientation sera la grille à résoudre.
    """
    
    
    angles = [0,90,180,270]
    distance_moyenne=0.0
    grille=[]
    angleOpt=0
    for angle in angles:
        sudoku, distance, zero = single_recognition(im, 9, angle)
        print("> Orientation",angle,"° : distance moyenne entre plus poches voisins :", distance)
        
        #Recherche de la distance moyenne minimale. La condition (distance == 0) validée signifie que la reconnaissance n'a pas fonctionné et/ou que la grille est invalide.
        if (distance<distance_moyenne or distance_moyenne==0) and (distance != 0):
            grille=sudoku
            distance_moyenne = distance
            angleOpt = angle
            iszero = zero
            
    print(grille)
    print("Angle Valentin : ", angleOpt)
    
    #Si cette condition n'est pas satisfaite, cela signifie qu'il y a très probablement deux coefficients sur la même ligne, colonne ou bloc.
    try:
        assert (len(grille)!=0), "La grille reconnue ne semble pas respecter les règles du sudoku"
    except:
        print("Veuillez réessayer")
        alarm()
    
    #A ce stade, la grille optimale est choisie. Il reste à savoir si elle contient des zéros. Si tel est le cas, la grille ne doit pas être envoyée à l'algorithme de résolution...
    try:
        assert (iszero == False), "Un zéro a été détecté dans la grille. Veuillez changer les conditions d'éclairage ou d'inclinaison"
    except:
        print("Veuillez réessayer")
        alarm()
        
    #Remplacement des cases vides (ici, coefficient = 10) par des zéros. Ces coefficients 10 étaient précédemment nécessaires pour assurer la vérification de la grille. Ainsi, si l'algorithme détecte deux zéros dans la grille (par exemple, si celle-ci est mal tournée), la reconnaissance s'arrête immédiatement (gain de temps).
    for i in range(0,9):
        for j in range(0,9):
            if grille[i][j]==10:
                grille[i][j] = 0

    return(grille, angleOpt)