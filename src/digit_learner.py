"""
@author     Valentin
@brief      Functions to generate a database of digit using digit pictures.

Digit database: EnglishFnt.tgz on http://www.ee.surrey.ac.uk/CVSSP/demos/chars74k/
"""

import os

import numpy as np
import cv2
import time
import matplotlib.pyplot as plt
import random

init = time.time()

def maximum(contours):
    """
    @param   contours   a list of contours points generated by cv2.findContours
    @return  cnt        a contour
    @brief   Permet de récupérer le plus grand contour d'une liste au sens de son aire.
    """
    
    area_max=0
    cnt_max=contours[0]
    for cnt in contours:
        if cv2.contourArea(cnt)>area_max:
            area_max = cv2.contourArea(cnt)
            cnt_max = cnt
    return(cnt_max)

def ask_ratio():
    """
    @return     a ratio, or 0 if a string is entered
    @brief      Fonction permettant de récupérer un ratio utile pour partager la base d'image entre les étapes d'apprentissage et les étapes de test.
    """
    ratio = input("Quel ratio apprentissage / test voulez-vous? Tapez help pour plus d'informations\n")
    
    try:
        ratio_double = float(ratio)
        assert ratio_double > 0.005 and ratio_double < 0.99
        
    except AssertionError:
        print("Le ratio doit être compris entre 0.005 et 0.99")
        print("Pour obtenir de l'aide, tapez 'help'.\n")
        return(0)
        
        
    except ValueError:
        print("########################")
        print("La base de donnée comporte 1016 images par digit. Sur ce nombre, une partie des images va servir à générer la base de donnée utilisée par l'algorithme de reconnaissance, et l'autre va servir à tester et caractériser la précision de l'algorithme\n")
        print("Plus le ratio est élevé, plus la base de donnée sera lourde, et moins la phase de test sera conséquente. Un ratio trop léger donne une base moins complète, ce qui peut jouer sur la précision de l'algorithme.")
        time.sleep(1)
        print("Note 1: des résultats satisfaisants sont obtenus dès 0.1 de ratio")
        time.sleep(1)
        print("Note 2: une optimisation du nombre de plus proches voisins utilisés va être réalisée. Ainsi, l'apprentissage va se répéter 10 fois. Un ratio trop gros rendra l'exécution longue")
        print("########################\n")
        return(0)
    
    return(ratio_double)
    
    
def digit_recognizer_simple(im, k):
    """
    @param   im          a picture of digit taken from the database
    @param   k           number of nearesy neighbors taken into account
    @return  resultat    a digit
    @brief   Réalise la reconnaissance d'un digit de la base de donnée.
    
    
    Cette fonction est utilisée pour la phase de test
    """
    
    #Seuillage inversé, étant donné que le contour est détecté autour d'éléments blancs (la couleur noire est neutre)
    _, thresh = cv2.threshold(im,0,255,cv2.THRESH_BINARY_INV)
    #Pré-traitement pour s'approcher d'un cas réel : floutage
    blur =  cv2.GaussianBlur(thresh,(5,5),0)
    
    _ ,contours,hierarchy = cv2.findContours(blur,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)
    cnt = maximum(contours)
    #Création d'un contour "rectangulaire" autour du digit : x,y : coordonnées en bas à gauche, w largeur, h hauteur
    [x,y,w,h] = cv2.boundingRect(cnt)
    
    #Sélection du digit uniquement
    roi = thresh[y:y+h,x:x+w]
    roismall = cv2.resize(roi,(10,10))
    roismall = roismall.reshape((1,100))
    roismall = np.float32(roismall)
    retval, results, neigh_resp, dists = model.findNearest(roismall, k)
    resultat = int(results[0][0])
    return(resultat)
    
    
  
##Détermination du ratio apprentissage / test
print("Bienvenue dans la fonction d'apprentissage")
time.sleep(0.5)

ratio = ask_ratio()
while ratio==0:
    ratio = ask_ratio()
    
    
    
if input("\nVoulez-vous que l'algorithme détermine une valeur optimale de k (nombre de plus proches voisins) à prendre en compte ? Tapez '1' si oui, '0' sinon (3 par défaut). Cette opération peut prendre un certain temps si le ratio est élevé.\n")=='1':
    adaptative_k=True
    intervalle = range(2,10)
else:
    adaptative_k=False
    intervalle = range(3,4)

nb_apprentissage = round(1016*ratio)    # Nombre d'image prises en compte dans la base de donnée pour l'apprentissage
nb_test = 1016-nb_apprentissage         # Nombre d'image prises en compte dans la base de donnée pour les tests
nb=0                                    #indice de boucle

precision = []  #Tableau contenant la précision des tests en fonction du nombre de plus proches voisins

##Récupération du chemin d'accès à la base d'image
path = os.getcwd() 

for k in intervalle:
    
    print("\n-----------------------")
    print("Apprentissage - k =",k)
    print("-----------------------\n")
    
    
    alreadylearned = [[],[],[],[],[],[],[],[],[],[]]
    
    ##Création des tableaux de données
        #tableau contenant des vecteurs ligne de taille 100 correspondant aux images de la base d'apprentissage
    samples =  np.empty((0,100))    
        #tableau correspondant aux labels, i.e. aux digits représentés (0,1,2,3,4,5,6,7,8 ou 9)
    responses = []
    
    ##Apprentissage
    for i in range(0,10):
        nb=0
        print("> Apprentissage de "+str(i))
        while nb<nb_apprentissage:
            
            #Choix aléatoire d'un fichier image dans la base 
            j=random.randint(1,1016)
            while j in alreadylearned[i]:   #On ne veut pas apprendre plusieurs fois la même image.
                j=random.randint(1,1016)
                
            alreadylearned[i].append(j)
            
            #Lecture de l'image dans le système de fichiers
            
            #print(path+'\dataset\\'+str(i)+'\\'+str(j)+'.png')
            im = cv2.imread(path+'\dataset\\'+str(i)+'\\'+str(j)+'.png', 0)
            
            #Pré-Traitement pour plus de correspondance avec les images qui seront traitées.
            
            blur =  cv2.GaussianBlur(im,(5,5),0)          #floutage gaussien
            
            #seuillage inversé pour utiliser la fonction cv2.findContours
            #Si l'image est noire sur fond blanc, le contour sera autour du blanc...
            im2 =  cv2.adaptiveThreshold(blur,255,1,1,11,2) 
            
            #cv2.imshow('test', im2)
            #cv2.waitKey0.(0)
            
            #Détection des contours
            _ ,contours,hierarchy = cv2.findContours(im2,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)
    
            
            cnt = maximum(contours)
            [x,y,w,h] = cv2.boundingRect(cnt)
            
            # A des fins de test, décommenter si besoin
            # cv2.rectangle(im,(x,y),(x+w,y+h),(50,200,125),5)
            # cv2.imshow('Fen'+str(j)+str(i),im)
            # cv2.waitKey()
            
            responses.append(i)
            roi = im2[y:y+h,x:x+w]                  #Recadrage sur le digit
            roismall = cv2.resize(roi,(10,10))      #Redimentionnement du digit sur 100 pixels
            sample = roismall.reshape((1,100))      #Mise en forme pour le tableau sample
            samples = np.append(samples,sample,0)
            
            nb+=1
        
    ##Sauvegarde des données générées          
    responses = np.array(responses,np.float32)
    responses = responses.reshape((responses.size,1))
    print('Training completed in '+str((time.time()-init)/60)+' min')
    
    np.savetxt('digitsamples.data',samples)
    np.savetxt('digitresponses.data',responses)
    
    ##Test
    
    #Chargement de la base
    samples = np.loadtxt('digitsamples.data',np.float32)
    responses = np.loadtxt('digitresponses.data',np.float32)
    responses = responses.reshape((responses.size,1))
    
    #Génération du modèle
    model = cv2.ml.KNearest_create()
    model.train(samples,cv2.ml.ROW_SAMPLE,responses)
    
    reconnus, total = 0, 0 #Permettront de déterminer la précision
    
    for i in range(0,10):
        nb=0
        print("> Test de "+str(i))
        j=1
        while nb<nb_test:
            
            #Choix aléatoire d'un fichier image dans la base 
            while j in alreadylearned[i] and (j<1016):
                j+=1
            
            #Lecture de l'images dans le système de fichiers
            #print(path+'\dataset\\'+str(i)+'\\'+str(j)+'.png')
            im = cv2.imread(path+'\dataset\\'+str(i)+'\\'+str(j)+'.png', 0)
            
            if digit_recognizer_simple(im,k) == i:
                reconnus+=1
            
            nb+=1
            total+=1
            j+=1
    
    new_precision = 100*reconnus/total
    precision.append(new_precision)
    print("Précision : ", round(new_precision,2), " %, k =",k,"voisins")
    

##Affichage de la courbe de précision

if adaptative_k:
    print("\nLa valeur optimale de k vaut ici",precision.index(max(precision))+2)
    plt.figure("Précision de l'algorithme en fonction du nombre de voisins considérés")
    plt.xlabel("Nombre de voisins considérés")
    plt.ylabel("Précision de l'algorithme (en %)")
    plt.title("Précision de l'algorithme en fonction du nombre de voisins considérés")
    plt.plot(range(2,10), precision, 'x-')
    plt.show()